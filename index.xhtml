<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="GENERATOR" content="LyX 2.3.4.2" />
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>LLVM GSoC '20 Hot/Cold Splitting</title>
<style type='text/css'>
/* Layout-provided Styles */
h1.title {
font-size: x-large;
margin-bottom: 1ex;
text-align: center;

}
div.author {
font-size: large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: center;

}
div.standard {
	margin-bottom: 2ex;
}
h5.paragraph {
font-weight: bold;
font-size: medium;
margin-top: 0.4ex;
text-align: left;

}
h5.paragraph_ {
font-weight: bold;
font-size: medium;
margin-top: 0.4ex;
text-align: left;

}
h2.section_ {
font-weight: bold;
font-size: x-large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: left;

}
div.plain_layout {
text-align: left;

}
ul.itemize {
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
text-align: left;

}
div.lyx_code {
font-family: monospace;
margin-top: 0.5ex;
margin-bottom: 0.5ex;
margin-left: 3ex;
margin-right: 3ex;
text-align: left;

}
ol.enumerate {
margin-top: 0.7ex;
margin-bottom: 0.7ex;
margin-left: 3ex;
text-align: left;

}
table {
	border-collapse: collapse;
	display: inline-block;
}
td {
	border: 1px solid black;
	padding: 0.5ex;
}
span.foot_label {
	vertical-align: super;
	font-size: smaller;
	font-weight: bold;
	text-decoration: underline;
}
div.foot {
	display: inline;
	font-size: small;
	font-weight: medium;
	font-family: serif;
	font-variant: normal;
	font-style: normal;
}
div.foot_inner { display: none; }
div.foot:hover div.foot_inner {
	display: block;
	border: 1px double black;
	margin: 0em 1em;
	padding: 1em;
}
span.flex_url {
font-family: monospace;
}


</style>
</head>
<body dir="auto">
<h1 class="title" id='magicparlabel-1'>LLVM GSoC '20 Hot/Cold Splitting</h1>
<div class="author" id='magicparlabel-2'>Ruijie Fang <span style='font-family:monospace;'>&lt;ruijief@princeton.edu&gt;</span></div>
<div class="standard" id='magicparlabel-3'>Note: This page is compiled by LyX into XHTML format; it works best in Firefox, as the footnotes are properly displayed. When you encounter images, click to enlarge them.</div>

<div class="standard" id='magicparlabel-4'>Permanent URL to this document: <a href="https://tr5.org/~ruijie/gsoc20_hcs/index.xhtml">https://tr5.org/~ruijie/gsoc20_hcs/index.xhtml</a></div>
<h5 class="paragraph" id='magicparlabel-5'><span class="paragraph_label"></span> Mentors</h5>
<div class="standard" id='magicparlabel-6'>Aditya Kumar, Rodrigo Rocha</div>
<h5 class="paragraph_" id='magicparlabel-7'>Synopsis</h5>
<div class="standard" id='magicparlabel-8'>The objective of this project is to find ways to improve the outlining ability of the hot/cold splitting optimization pass in the LLVM compiler on two real-world workloads: qemu (both userspace and full-system emulation) and Firefox. In terms of deliverable code, my contribution to this project is a series of small patches to the Hot/Cold Splitting pass that added section splitting, longjmp outlining, EH outlining capabilities and a bugfix in LLVM's basic block extractor (CodeExtractor). In addition to contributing code, I also collected benchmark data on Firefox and qemu codebases to test different ideas to improve hot/cold splitting's outlining ability, and wrote scripts to automate the testing/benchmarking workflow. During the three-month process, I met with Aditya and Rodrigo weekly and had routine conversations via Discord for discussion. This report is a comprehensive summary of my work performed this summer during GSoC'20 and relevant ideas discussed between me and my mentors.</div>
<h2 class="section_" id='magicparlabel-9'>Contributions</h2>
<div class="standard" id='magicparlabel-10'>We found that when applying PGO+HCS to compile Firefox results in a 5% speedup in Firefox performance benchmarks (talos-test perf-reftests):</div>



<div class="standard" style='text-align: center;' id='magicparlabel-11'><table><tbody><tr><td align='center' valign='top'>

</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-33'>Time (mean)</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-36'>Time (median)</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-39'>-O2 Baseline</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-42'>1015.8s</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-45'>1015.0s</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-48'>-O2 PGO+Vanilla HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-51'>961.3s</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-54'>961.0s</div>
</td>
</tr></tbody>
</table>
</div>

<div class="standard" style='text-align: center;' id='magicparlabel-55'><img style='width:30%;' src='0_home_rjf_Downloads_68747470733a2f2f692e696d6775722e636f6d2f6e32423558686d2e706e67.png' alt='image: 0_home_rjf_Downloads_68747470733a2f2f692e696d6775722e636f6d2f6e32423558686d2e706e67.png' />
</div>

<div class="standard" id='magicparlabel-56'>We also found that Hot/Cold Splitting can reduce the code size of Firefox by 2%:</div>



<div class="standard" style='text-align: center;' id='magicparlabel-57'><table><tbody><tr><td align='center' valign='top'>

</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-79'>Opt Level</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-82'>Size (incl. dynamic libraries)</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-85'>Vanilla HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-88'>-O3</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-91'>2.247788640 GB</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-94'>baseline</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-97'>-O3</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-100'>2.299546240 GB</div>
</td>
</tr></tbody>
</table>
</div>
<h5 class="paragraph" id='magicparlabel-101'><span class="paragraph_label"></span> Code Contributions.</h5>
<div class="standard" id='magicparlabel-102'>My code contribution comes in the form of a series of patches on LLVM's Phabricator:</div>

<ul class="itemize" id='magicparlabel-103'><li class="itemize_item"><a href="https://reviews.llvm.org/D69257">D69257</a> (Outlining noreturn functions unless a longjmp): Add capability to outline noreturning functions except longjmp intrinsics.</li>
<li class="itemize_item"><a href="https://reviews.llvm.org/D85331">D85331</a> (Add options for splitting cold functions into separate section): Add section-splitting capability: Put cold functions into a separate section into compiled binary.</li>
<li class="itemize_item"><a href="https://reviews.llvm.org/D85628">D85628</a> (Add command line option for supplying cold function names via user-input): Add command line option to take in a list of cold function names.</li>
<li class="itemize_item"><a href="https://reviews.llvm.org/D84468">D84468</a> (Add splitting delta option to split more small blocks) Add option to add a user-defined &ldquo;delta&rdquo; value to boost the cost model's benefit score.</li>
<li class="itemize_item"><a href="https://reviews.llvm.org/D86832">D86832</a> (Add support for outlining Itanium EH blocks by hoisting calls to eh.typeid.for intrinsic) Support outlining Itanium-style exception handling regions.</li>
</ul>
<h5 class="paragraph" id='magicparlabel-108'><span class="paragraph_label"></span> Additional Contributions.</h5>
<div class="standard" id='magicparlabel-109'>Additional contributions come in the form of scripts that automate the process of benchmarking different hot/cold splitting implementations and collecting the resultant benchmark data. The scripts are listed below:</div>

<ul class="itemize" id='magicparlabel-110'><li class="itemize_item"><a href="https://github.com/ruijiefang/llvm-hcs/tree/hcs-dot-printer">https://github.com/ruijiefang/llvm-hcs/tree/hcs-dot-printer</a>: A version of hotcoldsplit that prints out dot files of the modified CFG with detected cold blocks outlined in red and split cold blocks outlined in yellow, for visualizing hot/cold splitting in action.</li>
<li class="itemize_item"><a href="https://github.com/ruijiefang/llvm-hcs/tree/early-stage-hcs">https://github.com/ruijiefang/llvm-hcs/tree/early-stage-hcs</a>: A version of hotcoldsplit that is scheduled just before ModuleInliner in the optimization pipeline (needs to enable the new PassManager in clang to work).</li>
<li class="itemize_item"><a href="https://github.com/ruijiefang/llvm-hcs/tree/arcpatch-D57265/gsoc-ruijief">Scripts used for running HCS compilation benchmarks on qemu and firefox.</a></li>
<li class="itemize_item"><a href="https://github.com/ruijiefang/llvm-hcs/tree/sese">https://github.com/ruijiefang/llvm-hcs/tree/sese</a>: (Work in progress; detailed in the future works section). Adding maximal single-entry-single-exit (SESE) region outlining capability to hot/cold splitting.</li>
</ul>
<h2 class="section_" id='magicparlabel-114'>Project Timeline</h2>
<h5 class="paragraph" id='magicparlabel-115'><span class="paragraph_label"></span> Initial Plan: Benchmarking qemu.</h5>
<div class="standard" id='magicparlabel-116'>We started our work by collecting benchmark information on qemu userspace and qemu wholesystem benchmarks<div class="foot"><span class="foot_label">1</span><div class="foot_inner"><div class="plain_layout" id='magicparlabel-120'>The qemu version used is qemu trunk @ commit <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='monospace'>
   <mrow><mn>06</mn><mi>c</mi><mn>4</mn><mi>c</mi><mi>c</mi><mn>3660</mn><mi>b</mi><mn>366278</mn><mi>b</mi><mi>d</mi><mi>c</mi><mn>7</mn><mi>b</mi><mi>c</mi><mn>8</mn><mi>b</mi><mn>6677032</mn><mi>d</mi><mn>7</mn><mi>b</mi><mn>1118</mn><mi>c</mi>
   </mrow>
  </mstyle>
 </mrow></math></div>
</div></div>. Userspace qemu (whose binary size is smaller) can be used to run individual binaries, whereas wholeystem qemu (whose binary size is larger) is used to simulate an entire virtual machine, for running payloads such as operating system images. Instrumenting userspace qemu proved to be relatively problematic, due to qemu's nature as a machine code translator: LLVM instrumentation works by injecting extra code, (via the compiler-rt infrastructure) which writes instrumentation data to disk, into the program's exit handler. However, upon receiving an exit signal, the qemu userspace emulator will immediately translate and feed the appropriate exception instruction into the host CPU, thereby executing the emulated program's exit handlers rather than qemu's own exit handlers. Therefore, to appropriately collect instrumentation data, we had to modify the qemu source code to call qemu's own exit handlers<div class="foot"><span class="foot_label">2</span><div class="foot_inner"><div class="plain_layout" id='magicparlabel-124'>A fork of qemu modified for PGO instrumentation can be found here:<a href=" https://github.com/ruijiefang/qemu-x86_64-linux-benchmark"> https://github.com/ruijiefang/qemu-x86_64-linux-benchmark</a></div>
</div></div>.</div>

<div class="standard" id='magicparlabel-125'>For userspace qemu benchmark, we utilized userspace qemu and the system's default clang/clang++ to compile postgresql, and measured the overall compile time. For wholesystem qemu, we measured the time spent booting up Ubuntu 16.04 and running several of byte-unixbench benchmarks using x86_64 wholesystem qemu.</div>
<h5 class="paragraph" id='magicparlabel-126'><span class="paragraph_label"></span> Insignificant results on qemu made us switch to benchmarking firefox.</h5>
<div class="standard" id='magicparlabel-127'>However, as seen in the results section, the benefits of hot/cold splitting on qemu was not obvious, and most of the experiments yielded no gains beyond noise. We think the reason is as follows:</div>

<div class="standard" id='magicparlabel-128'>1. The size of qemu binaries are small (~15MB for userspace and ~50MB for x86_64 wholesystem binaries)</div>

<div class="standard" id='magicparlabel-129'>2. The computer on which we ran the benchmarks has an Intel Xeon E5-1607 CPU, 32GB ECC RAM, and 10MiB L3 cache. The large cache sizes and the powerfulness of the CPU rendered the gains produced by an icache optimization like Hot/Cold Splitting insignificant.</div>

<div class="standard" id='magicparlabel-130'>3. qemu is written in C; whereas, hot/cold splitting should be more effective for C++, where the code base is more complex and leaves room for outlining optimizations.</div>

<div class="standard" id='magicparlabel-131'>As such, we decided to switch to benchmarking firefox (via PGO-compiling Firefox's repository mozilla-central); the Firefox production binary size (with dynamic libraries included) is ~2-3GBytes, depending on the compiler flag and optimizations used, together with the amount of C++ code contained in Firefox makes it a nice candidate for our benchmarks. Our methodology for benchmarking firefox is to compile Firefox using PGO+Hot/Cold Splitting, then run a performance benchmark using the &ldquo;talos-test perf-reftest&rdquo; testsuite, which is the same set of tests we use to obtain instrumentation data.</div>

<ul class="itemize" id='magicparlabel-132'><li class="itemize_item">Deliverables: HCS pass that prints CFGs with detected cold blocks and extracted blocks annotated available at: <a href="https://github.com/ruijiefang/llvm-hcs/tree/hcs-dot-printer">https://github.com/ruijiefang/llvm-hcs/tree/hcs-dot-printer</a></li>
<li class="itemize_item">Scripts available at: <a href="https://github.com/ruijiefang/llvm-hcs/tree/arcpatch-D57265/gsoc-ruijief">https://github.com/ruijiefang/llvm-hcs/tree/arcpatch-D57265/gsoc-ruijief</a></li>
</ul>
<h5 class="paragraph" id='magicparlabel-134'><span class="paragraph_label"></span> Improvement Idea 1: Hot/Cold Splitting + Inliner.</h5>
<div class="standard" id='magicparlabel-135'>The first improvement idea for applying Hot/Cold splitting to Firefox was suggested by Rodrigo. We devised an HCS implementation that runs early in the new PassManager's PGO optimization pipeline, immediately before the stock ModuleInliner pass: https://github.com/ruijiefang/llvm-hcs/tree/arcpatch-D57265. Thus, we outline code every time before we inline. As seen in the results section, this approach greatly increased the number of cold blocks detected and split, at the expense of blowing up the code size by more than 5%. However, no significant performance benefits were observed. Since this approach causes an increase in code size at the expense of outlining more blocks, and the modifications to the source code was rather involved, we did not propose it as a patch to Phabricator. Instead, it lives as a branch on our own LLVM fork: https://github.com/ruijiefang/llvm-hcs/tree/arcpatch-D57265.</div>

<ul class="itemize" id='magicparlabel-136'><li class="itemize_item">Deliverables: Implementation at <a href="https://github.com/ruijiefang/llvm-hcs/tree/early-stage-hcs">https://github.com/ruijiefang/llvm-hcs/tree/early-stage-hcs</a>.</li>
</ul>
<h5 class="paragraph" id='magicparlabel-137'><span class="paragraph_label"></span> Improvement Idea 2: Adding a Delta Option.</h5>
<div class="standard" id='magicparlabel-138'>The second improvement idea stems from our analysis of the behavior of the cost model when compiling qemu with hot/cold splitting. By making a histogram of the hot/cold split cost model on qemu blocks, we found there are a large number of blocks with negative benefit-penalty differences, but the difference themselves are relatively small:</div>

<div class="standard" style='text-align: center;' id='magicparlabel-139'><img style='width:50%;' src='1_home_rjf_Downloads_delta.png' alt='image: 1_home_rjf_Downloads_delta.png' />
</div>

<div class="standard" style='text-align: center;' id='magicparlabel-140'><img style='width:50%;' src='2_home_rjf_Downloads_delta2.png' alt='image: 2_home_rjf_Downloads_delta2.png' />
</div>

<div class="standard" id='magicparlabel-141'>Therefore, we experimented with whether splitting these blocks with negative benefit-penalty differences in range <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>

  <mrow><mi> &epsi; </mi><mo>,</mo><mn>0</mn>
  </mrow>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo>

 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi> &epsi; </mi>
 </mrow></math> is a small value between -1 and -5. The result, as outlined in the benchmark data section, is while there is a slight gain in performance data in qemu benchmarks, there is a code size increase. Vedant Kumar later pointed us towards an earlier patch he implemented, D59715, which adds more granular input size checking to the cost model for computing penalties. The proposed changes in D59715 is confirmed to both perform well (with negligible effect on performance and a reduction in code size) on Firefox benchmarks. Our modification is proposed as a patch (<a href="https://reviews.llvm.org/D84468">https://reviews.llvm.org/D84468</a>).</div>
<h5 class="paragraph" id='magicparlabel-142'><span class="paragraph_label"></span> Improvement Idea 3: Put cold functions in a different section.</h5>
<div class="standard" id='magicparlabel-143'>Another improvement idea we tried is to place cold functions into a different section in order to further increase instruction cache affinity for hot functions. This is implemented in patch D69257 (<a href="https://reviews.llvm.org/D69257">https://reviews.llvm.org/D69257</a>), and thereafter merged into LLVM trunk. Together with LLVM's newly added LLVM machine function splitter optimization pass, the modification is shown to be benefitial in terms of reducing the number of pagefaults<div class="foot"><span class="foot_label">3</span><div class="foot_inner"><div class="plain_layout" id='magicparlabel-147'>See relevant discussions and experiment results in <a href="https://reviews.llvm.org/D85368">https://reviews.llvm.org/D85368</a></div>
</div></div>.</div>
<h5 class="paragraph" id='magicparlabel-148'><span class="paragraph_label"></span> Improvement Idea 4: Improved static analysis with longjmp and EH outlining.</h5>
<div class="standard" id='magicparlabel-149'>As a first improvement, we merged Aditya's patch D69257 (<span class="flex_url">https://reviews.llvm.org/D69257</span>), which adds capability for outlining noreturn functions unless a longjmp. Next, we proceeded to work on outlining Itanium-style exception handling blocks. Itanium-style EH handling in LLVM follows roughly the following structure:</div>

<div class="lyx_code" id='magicparlabel-154'><div class="lyx_code_item">invoke-***&nbsp;</div>
<div class="lyx_code_item">|&nbsp;</div>
<div class="lyx_code_item">lpad-***&nbsp;</div>
<div class="lyx_code_item">|&nbsp;</div>
<div class="lyx_code_item">catch.dispatch&nbsp;</div>
<div class="lyx_code_item">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</div>
<div class="lyx_code_item">catch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</div>
<div class="lyx_code_item">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</div>
<div class="lyx_code_item">catch.fallthrough</div>
<div class="lyx_code_item">|</div>
<div class="lyx_code_item">resume</div>
</div>

<div class="standard" id='magicparlabel-165'><br />

</div>

<div class="standard" id='magicparlabel-166'>With our implementation of EH outlining, we are able to outline most non-nested try/catch regions in C++ code. The idea is to hoist the problematic calls to eh.typeid.for to some earlier entry block before the region dominated by the landing pad block, and split the block containing the landingpad instruction into a block containing only the landingpad instruction and possibly some phi-nodes, and a block containing the rest of the EH entry block, terminated by an unconditional branch to catch.dispatch. This implementation supports some partial outlining of nested EH regions as well.</div>

<div class="standard" id='magicparlabel-167'>An example of try/catch outlining is as follows. We will focus on the following C++ code:</div>

<div class="lyx_code" id='magicparlabel-168'><div class="lyx_code_item">int&nbsp;main()</div>
<div class="lyx_code_item">{</div>
<div class="lyx_code_item">&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;3;</div>
<div class="lyx_code_item">&nbsp;&nbsp;try&nbsp;{</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;==&nbsp;3)&nbsp;throw&nbsp;i;</div>
<div class="lyx_code_item">&nbsp;&nbsp;}&nbsp;catch&nbsp;(int&nbsp;e)&nbsp;{</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;exit(i);</div>
<div class="lyx_code_item">&nbsp;&nbsp;}&nbsp;catch&nbsp;(char&nbsp;c)&nbsp;{</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;exit(2);</div>
<div class="lyx_code_item">&nbsp;&nbsp;}&nbsp;catch&nbsp;(long&nbsp;d)&nbsp;{</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;exit(4);</div>
<div class="lyx_code_item">&nbsp;&nbsp;}&nbsp;catch&nbsp;(string&nbsp;s)&nbsp;{</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;exit(5);</div>
<div class="lyx_code_item">&nbsp;&nbsp;}</div>
<div class="lyx_code_item">&nbsp;&nbsp;return&nbsp;0;</div>
<div class="lyx_code_item">}</div>
</div>
<div class="standard" id='magicparlabel-184'>The above code produces the following (unoptimized) IR CFG:</div>

<div class="standard" style='text-align: center;' id='magicparlabel-185'><img style='width:20%;' src='3_home_rjf_Projects_gsoc_examples_try_nosplit.png' alt='image: 3_home_rjf_Projects_gsoc_examples_try_nosplit.png' />
</div>

<div class="standard" id='magicparlabel-186'>Our EH outliner implementation hoists the call to eh.typeid.for contained in the <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='monospace'>
   <mrow><mi>c</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mn>.</mn><mi>d</mi><mi>i</mi><mi>s</mi><mi>p</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi>
   </mrow>
  </mstyle>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='monospace'>
   <mrow><mi>c</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mn>.</mn><mi>f</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>g</mi><mi>h</mi>
   </mrow>
  </mstyle>
 </mrow></math>blocks into<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='monospace'>
   <mrow><mi>l</mi><mi>p</mi><mi>a</mi><mi>d</mi>
   </mrow>
  </mstyle>
 </mrow></math> block, splits the landingpad block in half, and feeds the transformed region starting from the direct successor of the new lpad block into the OutliningRegion outliner. The result is as follows, with two regions extracted:</div>

<div class="standard" style='text-align: center;' id='magicparlabel-187'><img style='width:30%;' src='4_home_rjf_Projects_gsoc_examples_eh_pngs_main.png' alt='image: 4_home_rjf_Projects_gsoc_examples_eh_pngs_main.png' />
</div>

<div class="standard" style='text-align: center;' id='magicparlabel-188'><img style='width:30%;' src='5_home_rjf_Projects_gsoc_examples_eh_pngs_main_cold_4.png' alt='image: 5_home_rjf_Projects_gsoc_examples_eh_pngs_main_cold_4.png' />
<img style='width:30%;' src='6_home_rjf_Projects_gsoc_examples_eh_pngs_main_cold_1.png' alt='image: 6_home_rjf_Projects_gsoc_examples_eh_pngs_main_cold_1.png' />
</div>

<div class="standard" style='text-align: center;' id='magicparlabel-189'><img style='width:30%;' src='7_home_rjf_Projects_gsoc_examples_eh_pngs_main_cold_2.png' alt='image: 7_home_rjf_Projects_gsoc_examples_eh_pngs_main_cold_2.png' />
<img style='width:30%;' src='8_home_rjf_Projects_gsoc_examples_eh_pngs_main_cold_3.png' alt='image: 8_home_rjf_Projects_gsoc_examples_eh_pngs_main_cold_3.png' />
</div>

<div class="standard" id='magicparlabel-190'>The difficulties of outlining are as follows:</div>

<ol class="enumerate" id='magicparlabel-191'><li class="enumerate_item">We cannot extract the block containing the invoke, otherwise we'll potentially extract the hot branch as well; </li>
<li class="enumerate_item">We cannot extract the entire landing pad block, since the first instruction after the unwind edge into the lpad block must be the landingpad instruction. </li>
<li class="enumerate_item">It seems possible to simply split the lpad block into two from the first instruction, and then outling starting from there; this is analogous to issue #4, which we outline below; </li>
<li class="enumerate_item">The block at catch.dispatch contains potentially a series of calls to the eh.typeid.for intrinsic to use function-specific type information to match if the catch call can go through. As such, CodeExtractor cannot extract these calls (See detailed discussion and example in https://bugs.llvm.org/show_bug.cgi?id=39545). Making typeid.for outlining-friendly seems in general a difficult task, as the proposed patch in 39545 uses an entirely new pass to do so. </li>
<li class="enumerate_item">What remains is the idea of extracting the typeid.for intrinsic calls to further up in the control flow graph, and since we have rather normal control flow, we can do so safely and store the resultant values in some variable. However, consider the following example of nested throws:</li>
</ol>
<div class="standard" style='text-align: center;' id='magicparlabel-196'><img style='width:20%;' src='9_home_rjf_Projects_gsoc_examples_main.png' alt='image: 9_home_rjf_Projects_gsoc_examples_main.png' />
</div>

<div class="standard" id='magicparlabel-197'>Since there are multiple catch.dispatch blocks, we cannot simply extract calls to eh.typeid.for from them to an arbitrary block that precedes them. On hindsight, it seems like we can just extract the call instructions to the successor block (between itself and landingpad block) to catch.dispatch. However, doing so is potentially unsafe, since the fallthrough branch of a try block in an outer nesting directly goes into the catch.dispatch block in the inner nesting, which means we cannot use the eh.typeid.for values unless we insert a phi node. Expanding on our previous example, the following hoisted CFG needs a phi-node inserted in catch.dispatch3:</div>

<div class="standard" style='text-align: center;' id='magicparlabel-198'><img style='width:20%;' src='10_home_rjf_Projects_gsoc_examples_main3.png' alt='image: 10_home_rjf_Projects_gsoc_examples_main3.png' />
</div>

<div class="standard" id='magicparlabel-199'>A possible solution is to extract these call instructions to the highest post-landingpad block that dominates them. This is the "safe" strategy we currently implement: https://github.com/ruijiefang/llvm-hcs/tree/eh-prepare. However, there are still complex cases of nested throws we cannot fully outline, mainly because the current implementation of OutliningRegion does not guarantee to extract maximal SESE regions. A good example is the CFG example provided above.</div>

<div class="standard" id='magicparlabel-200'>Empirical data collected on compilation of Firefox suggests the EH outlining implementation is beneficial; in -Os compilation experiments, enabling EH outling leads to both reduced code size as well as an increased number of detected cold blocks. For detailed data, see the results section.</div>

<ul class="itemize" id='magicparlabel-201'><li class="itemize_item">Deliverables: Patch at <a href=" https://reviews.llvm.org/D86832"> https://reviews.llvm.org/D86832</a>.</li>
</ul>
<h5 class="paragraph" id='magicparlabel-202'><span class="paragraph_label"></span> Improvement Idea 5: Using user-supplied cold functions list to outline standard library functions.</h5>
<div class="standard" id='magicparlabel-203'>In some cases, the user might want to specify which functions are explicitly cold. We contributed a patch that adds two options, cold-functions-list and cold-functions-file that enables the user to supply lists of cold function names to hot/cold splitting. The optimization pass will then mark any function encountered with the same name as cold.</div>

<div class="standard" id='magicparlabel-204'>The patch aims to solve the issue of outlining cold paths induced by C++ static initializers. For instance, consider the following C++ code</div>

<div class="lyx_code" id='magicparlabel-205'><div class="lyx_code_item">struct&nbsp;foo&nbsp;{</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;[[gnu::weak]]&nbsp;foo()&nbsp;noexcept;</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;[[gnu::weak]]&nbsp;~foo();&nbsp;</div>
<div class="lyx_code_item">};</div>
<div class="lyx_code_item">void&nbsp;go()&nbsp;{</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;foo&nbsp;f;</div>
<div class="lyx_code_item">}</div>
<div class="lyx_code_item">void&nbsp;go_leaky()&nbsp;{</div>
<div class="lyx_code_item">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;foo&amp;&nbsp;f&nbsp;=&nbsp;*new&nbsp;foo();</div>
<div class="lyx_code_item">}</div>
</div>
<div class="standard" id='magicparlabel-215'>The static initializer inside function <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='monospace'>
   <mrow><mi>g</mi><mi>o</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
<mrow/>
<mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>

   </mrow>
  </mstyle>
 </mrow></math> compiles down to calls to standard library routines <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='monospace'>
   <mrow>__<mi>c</mi><mi>x</mi><mi>a</mi>_<mi>g</mi><mi>u</mi><mi>a</mi><mi>r</mi><mi>d</mi>_<mi>a</mi><mi>c</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>r</mi><mi>e</mi><mo>/</mo><mi>r</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>a</mi><mi>s</mi><mi>e</mi>
   </mrow>
  </mstyle>
 </mrow></math>. The idea is that the user can supply these functions as an option to hot/cold splitting in order to benefit from outlining them. However, the patch is still in review since many are unsure if the user-supplied cold functions approach a good idea.</div>

<ul class="itemize" id='magicparlabel-216'><li class="itemize_item">Deliverables: Patch at <a href="https://reviews.llvm.org/D85628">https://reviews.llvm.org/D85628</a>.</li>
</ul>
<h2 class="section_" id='magicparlabel-217'>Results</h2>
<h5 class="paragraph" id='magicparlabel-218'><span class="paragraph_label"></span> firefox, talos-test perf-reftest (-O2 6 runs, performance).</h5>


<div class="standard" id='magicparlabel-219'><table><tbody><tr><td align='center' valign='top'>

</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-259'>Time (mean)</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-262'>Time (median)</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-265'>Regions Detected</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-268'>Regions Split</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-271'>-O2 Baseline</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-274'>1015.8s</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-277'>1015.0s</div>
</td>
<td align='center' valign='top'>

</td>
<td align='center' valign='top'>

</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-286'>-O2 PGO+Vanilla HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-289'>961.3s</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-292'>961.0s</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-295'>152048</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-298'>69444</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-301'>-O2 PGO+Inliner HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-304'>959.444s</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-307'>959.0s</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-310'>157166</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-313'>74166</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-316'>-O2 D59715</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-319'>964.447s</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-322'>953.472s</div>
</td>
<td align='center' valign='top'>

</td>
<td align='center' valign='top'>

</td>
</tr></tbody>
</table>
</div>

<div class="standard" id='magicparlabel-665'><em>Summary.</em> In the performance benchmark shown above, we see that all three hot/cold splitting variants achieved a ~6% speedup over the -O2 baseline. In addition, the HCS+Inliner implementation detected and split more regions, due to its position in the early stage of the optimization pipeline, before inlining.</div>
<h5 class="paragraph" id='magicparlabel-329'><span class="paragraph_label"></span> firefox, code size.</h5>
<div class="standard" id='magicparlabel-330'>Comparing -Os baseline HCS with our EH-outliner-enabled HCS shows an increase in number of regions detected as well as a reduction in code size:</div>



<div class="standard" id='magicparlabel-331'><table><tbody><tr><td align='center' valign='top'>

</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-357'>Opt Level</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-360'>Size (incl. dynamic libraries)</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-363'>Regions Detected/Regions Split</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-366'>delta=0 HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-369'>-Os</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-372'>2.188262032 GB</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-375'>142678/62985</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-378'>EH outlining HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-381'>-Os</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-384'>2.187481424GB</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-387'>142081/62982</div>
</td>
</tr></tbody>
</table>
</div>

<div class="standard" id='magicparlabel-388'>Comparing code size across different HCS delta values and the D59715 patch suggests D59715 performs best in terms of code size reduction:</div>



<div class="standard" id='magicparlabel-389'><table><tbody><tr><td align='center' valign='top'>

</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-429'>Opt Level</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-432'>Size (incl. dynamic libraries)</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-435'>D59715</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-438'>-Os</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-441'>2.184796592 GB</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-444'>delta=5 HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-447'>-Os</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-450'>2.206931464 GB</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-453'>delta=-2 HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-456'>-O3</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-459'>2.270277648 GB</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-462'>delta=0 HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-465'>-O3</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-468'>2.247788640 GB</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-471'>D59715</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-474'>-O3</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-477'>2.243288440 GB</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-480'>delta=2 HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-483'>-O3</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-486'>2.259242024 GB</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-489'>delta=5 HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-492'>-O3</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-495'>2.270277648 GB</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-498'>baseline</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-501'>-O3</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-504'>2.299546240 GB</div>
</td>
</tr></tbody>
</table>
</div>

<div class="standard" id='magicparlabel-730'><em>Summary.</em> It is worthy of mentioning that although (as shown below) splitting blocks with the delta value &ldquo;boost&rdquo; might lead to potential performance gains, it leads to a code size blowup in general. On the other hand, patch D59715 leads to a consistent code size reduction without performance regressions. It is useful to note that due to differences in the transformations required in different optimization levels, the number of regions detected/regions split on changes as well.</div>
<h5 class="paragraph" id='magicparlabel-505'><span class="paragraph_label"></span> qemu-x86_64-userspace, clang compilation of postgresql.</h5>


<div class="standard" id='magicparlabel-506'><table><tbody><tr><td align='center' valign='top'>

</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-528'>Time (mean across 3 runs)</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-531'>-O2 HCS-enabled, delta=0</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-534'>46m4.717s (user) / 12m29.95s (real)</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-537'>-O2 HCS-enabled, delta=-5</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-540'>45m25s (real) / 12m25s (user)</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-543'>-O2 PGO baseline</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-546'>45m39.76s (real) / 12m23.28s (user)</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-549'>-O2 non-PGO baseline</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-552'>53m47.5s (user) / 14m40.3s (real)</div>
</td>
</tr></tbody>
</table>
</div>

<div class="standard" id='magicparlabel-553'>Regions split: 4332</div>

<div class="standard" id='magicparlabel-554'>Regions extracted: 2911 </div>
<h5 class="paragraph" id='magicparlabel-555'><span class="paragraph_label"></span> qemu-x86_64-wholesystem, ubuntu 16.04 startup+Byte-Unixbench benchmarks.</h5>
<div class="standard" id='magicparlabel-556'>This benchmark measures the time spent starting up ubuntu 16.04 and running several byte-unixbench benchmarks: pipe, spawn, context1, syscall, dhry2, each for 50,000 iterations.</div>



<div class="standard" id='magicparlabel-557'><table><tbody><tr><td align='center' valign='top'>

</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-587'>Time (mean across 6 runs)</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-590'>icache miss rate</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-593'>branch miss rate</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-596'>-O2 Vanilla HCS</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-599'>38.3379s (stddev: <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo> &plusmn; </mo><mn>.13</mn>%
  </mrow>
 </mrow></math>)</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-602'>1.952%</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-605'>1.692%</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-608'>-O2 HCS+Cold Sections</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-611'>38.4339s (stddev: <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo> &plusmn; </mo><mn>.18</mn>%
  </mrow>
 </mrow></math>)</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-614'>1.936%</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-617'>3.118%</div>
</td>
</tr><tr><td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-620'>-O2 PGO baseline</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-623'>38.66s (stddev: <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo> &plusmn; </mo><mn>.12</mn>%
  </mrow>
 </mrow></math>)</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-626'>1.912%</div>
</td>
<td align='center' valign='top'>
<div class="plain_layout" id='magicparlabel-629'>3.150%</div>
</td>
</tr></tbody>
</table>
</div>

<div class="standard" id='magicparlabel-876'><em>Summary.</em> No significant gains were observed between an implementation with hot/cold splitting applied versus an implementation with hot/cold splitting disabled. As mentioned in previous paragraphs, we think this is partly due to qemu's nature as an instruction translator, as well as its limitations in code size as well as programming language. However, we can see that PGO-enabled compilation in general is helpful.</div>
<h2 class="section_" id='magicparlabel-630'>Epilogue</h2>
<div class="standard" id='magicparlabel-631'>The end of my GSoC project marks not an end, but a new beginning. I look forward to continuing my work in the following directions with my two mentors.</div>
<h5 class="paragraph" id='magicparlabel-632'><span class="paragraph_label"></span> Future work.</h5>
<div class="standard" id='magicparlabel-633'>Based on my discussion with my mentor, we plan to carry our work in two directions in the future:</div>

<ol class="enumerate" id='magicparlabel-634'><li class="enumerate_item">Experiment on a &ldquo;pipeline&rdquo; of passes built for outlining: With the newly added machine function splitter pass, hot/cold splitting can be done both in the mid-end and backend. Future work in this direction, as proposed by my mentors, will focus on combining HCS+Inliner+MergeFunctions or HCS+EH Outlining+MergeFunctions for optimizing code size (in the first case, we have shown that scheduling HCS before inliner increases the number of basic blocks split; MergeFunctions can be then applied to merge similar cold functions; in the latter case, experience suggests that many catch blocks have similar structure, and the extracted catch blocks have a potential to be merged by the MergeFunctions pass). And finally, there might be additional gains by applying MachineFunctionSplitter after HotColdSplitting later in the pipeline.</li>
<li class="enumerate_item">The detection of maximal SESE regions in hot/cold splitting pass. The current OutliningRegions implementation in Hot/Cold Splitting does not detect maximal SESE/SEME regions surrounding a cold block, instead it detects a &ldquo;safe&rdquo; SESE region using the dominator/post-dominator tree. Although by default the RegionInfo pass in LLVM can be quadratic in worst-case time complexity, practical algorithms exist to detect maximal SESE regions. Work has already begun in this direction: I am in the process of implementing a maximal SESE region detection algorithm using the SESE program structure tree, and Rodrigo Rocha has a finished fork which implements maximal SEME detection using a SEME program structure tree. Both implementations work in linear-time and hence do not induce extra compilation overhead. Additional work can be done in this direction to apply these implementations to real-world workloads such as Firefox and see if any practical improvements over the existing implementation might be possible. </li>
</ol>
<h5 class="paragraph" id='magicparlabel-636'><span class="paragraph_label"></span> Acknowledgements.</h5>
<div class="standard" id='magicparlabel-637'>First and foremost, I would like to thank my two wonderful mentors, Aditya Kumar and Rodrigo Rocha, for their kind mentoring and helpful discussions which happened over Discord each week. I would also like to thank Vedant Kumar, Snehasish Kumar, and other LLVM contributors who reviewed my patches and provided insights. Finally, I would like to thank Google Summer of Code for their generous support, and the LLVM compiler infrastructure community for providing me opportunity to work on such an interesting and enabling project.</div>
</body>
</html>
